Уважаемые камрады.

Как известно, каждый уважаемый кодер рано или поздно пишет свой логер, парсер json и язык программирования. Поскольку первое и второе я уже написал, то мне ничего не остаётся, как представить миру мои наработки по инновционному языку программирования alang.

Итак, давайте приступим к разбору фичей, которые я нам принёс. 

## Синтаксис правого присваивания.
Когда компьютеры были большими, а динозавры маленькими, отцы основатели допустили ошибку, звшив в оператор присваивания логику перемещения правого в левое, что противно интуитивно ожидаемому (если вы не японец) движению левого в правое.

Движение правого в левое наложило отпечаток на  многие технологии и в результате мы получили:
- инструкцию ассемблера mov, в порядке аргументов которой вечно путаются студены 
- функции стандартной бибьлиотеки языка си, такие как `strcpy`, `memmove`.

И ладно бы мы всегда пользовались движением правого в левое, но тяга к интуитивно понятному породила:
- утилиты командной строки `cp`, `ln`.
- синтаксис функций стандартной библиотеки плюсов `std::copy` сотоварищи.

В подавляющем большинстве более менее современных инструментов движению правого в левое предпочитают длвижение левого в правое.

Но если с порядком аргументов в библиотеках каждый волен делать что хочет, то железобетонно вшитые в само тело языка программирования операторы присваивания до сих пор оставались незамеченными реформацией. В кое-то веки пора уже ударить расскалённым от праведного гнева молотом скепсиса и рациональности по этому недоразумению, что именуется оператором присваивания.

Язык alang вводит оператор правого присваивания:

```rust
42 => answer
foo(42) => answer
```

В силу понимания несовершенства человеческой природы и неспособности большей части сообщества к столь радикальным перестроениям, мы не стали изгонять старый оператор присваивания из языка полностью. Вы по прежнему можете его использовать, но будете получать ворнинги.

Кстати, такое синтаксис тоже валиден и может использоваться для некоторых хаков:
```rust
42 => answer = 42
```


## Управление типизацией, интерпретатор против компилятора.
И поныне не умолкают холивары, какая типизация предпочтительнее, статическая, динамическая, структурная, номинативная. alang в этом вопросе проезжает на всех санях сразу, позволяя менять типизацию по мере выполнения кода.

```rust
<typing:dynamic> // глобальное включение динамической типизации

fn foo(a,b) // динамически типизируемый код
{
	a + b => c
	return c
}

fn bar(a:i32,b) // динамическая типизация с номинативной проверкой типа 
{
	a + b => c
	return c
}

[typing:static] 
fn fubar(a,b) -> i32 // статически типизируемый код
{
	a + b => c : i32
	return c
}
```

Без задней мысли вводя этот функционал, я в какой-то момент обнаружил, что он открывает довольно широкий подход для оптимизаций, поскольку статическая часть поддаётся компиляции (интерпретатор выполняет её в jit режиме под нативное железо). 

Если программа написана полностью статически, мы можем компилироваться в исполняемый файл. (Тенхнически мы можем это делать и с динамическим кодом, но тогда приходится зашивать интерпретатор в кишки эльфа).