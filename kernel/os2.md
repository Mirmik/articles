# К вопросу о создании карманной ОС.

Научившись в первом приближении работе со временем и потренировавшись на диспетчере програмных таймеров, мы готовы попробовать свои силы в освоении концепциии процессов. 

На пальцах механизм процессов таков. Существуют диспетчер задач и список процессов. Диспетчер по некоторым, одному ему ведомым правилам, выбирает один из готовых к выполнению процессов и исполняет его, что бы это ни значило. В процессе исполнения процесс получает управление и совершив какие-то действия, тем или иным способом возвращает управление диспетчеру задач (или системному планировщику, если диспетчер задач не единственная сущность планирования).

Хотя, на первый взгляд, концепция процесса ясна и очевидна, реализация процессов встречает ряд организационных проблем. Процесс в широком смысле - это сущность, которая обладает вычислительным временем, представленна набором исполняемых им инструкций и, возможно, контролирует какие-то ресурсы системы. В первую очередь это пользовательские процессы, они имеют выделенную им область памяти, свой стек, контекст, контролируют файлы и примитивы ipc (inter process communication). Однако, есть и другие типы исполняемых единиц. Часто бывает нужно создать задачу, которая бы выполняла в системе некоторое простое действие и для которой избыточно выделять собственную область памяти. Например

Довольно очевидно, что процесс должен быть представлен в памяти некоторым объектом, хранящим информацию о его состоянии и служебные поля. Но какие? Многие ядра операционных систем содержат различные типов процессов. Например, в linux ранее была концепция легковесных задач tasklet, лешённых собственного стека. В linux механизм тасклетов к текущему моменту признан устаревшим и заменен более удобным механизмом workqueue, впрочем, не сильно изменившим суть. В других unix подобных системах концепция тасклетов здравствует и поныне. Тасклеты могут использоваться как нижние половины обработчиков прерываний или для управления автоматом ввода-вывода какого либо устройства. Тасклеты могут управляться отдельным диспетчером или же исполняться тем же менеджером задач, что и полноправные потоки.

Поскольку гипотетически существует множество различных вариантов процессов, которые могут требовать различных подготовительных операций для своего исполнения, мне нравится концепция реализованная в embox с абстрактной единицей исполнения `schedee` (scheduling entities). В рамках этой концепции разные типы процессов являются реализациями абстрактного schedee, а диспетчер задач ничего не зная об истинной природе вычислительной единицы. 

Если принять концепцию schedee, то структура абстрактного процесса `struct schedee` должна содержать только те поля, которые будут общими для всех типов процессов.

Диспетчеру задач является сердцем вычислительной системы. Каждый раз, когда один из процессов решает уступить и управление, или вынуждается к уступлению управления, поток исполнения попадает функцию планирования. 

```c
void kernel_schedule() 
{
	while(1) 
	{
		network_manager_step();
		timer_manager_step();
		schedee_manager_step();
	}
}

// Упрощённый вид функции schedee_manager_step
void schedee_manager_step()
{
	struct schedee * sch;

	...

	for (int priolvl = 0; priolvl < PRIORITY_TOTAL; priolvl++)
	{
		if (!dlist_empty(&runlist[priolvl]))
		{
			sch = list_first_entry(&runlist[priolvl], struct schedee, ctr.lnk);

			list_move_tail(&sch->ctr.lnk, &runlist[priolvl]);
			__schedee_execute(sch);

			return;
		}
	}

	//Nobody to run
	return;
}

```

# Так в чём же разница между монолитом и микроядром.

Интеллектуальная баталия сотен и тысяч сторонников и апологетов различных подходов к построению интерфейса системных вызовов ядра операционной системы и способа межпроцесной коммуникации, и по сей день будоражит просторы сети, хотя самый эпик этого противостояния,когда на информационном поле сошлись такие мастодонты, как Таненбаум и Торвальдс, ушёл безвозвратно.    

Для того, чтобы понять разницу между подходом монолита и подходом микроядра, рассмотрим несложную зарисовку из жизни процесса. Предположим, процесс хочет послать сообщение через serial интерфейс (com порт или usart, не имеет значения). Для этого процесс открывает файл соответствующего устройства с помощью библиотечной функции open, а потом зписывает данные с помощью функции write. Рассмотрим, что происходит при вызове write в случае монолита и в случае микроядра. 

```c
write(STDOUT, "HelloWorld", 10);
```

Монолит делает вызов write. Если речь идёт о системах с разделением режимов, библиотечный write расскладывает аргументы по регистрам, устанавливает номер команды и вызывает инструкцию системного монитора. В следующий момент поток оказывается на стороне ядра и вооружившись номером команды и аргументами,  



# Средства межпроцессной синхронизации. Очередь ожидания.

Идея межроцесной синхронизации.