Задача управления движением интересна сама по себе. Как заставить механическую куклу решать задачи в трёхмерном пространстве? Пусть даже простые. Подойти к столу, взять предмет, перенести его, положить в корзину. Не упасть по дороге. Никуда не врезаться.

Роботы boston dynamics, весьма красноречивы. Вещи которые они делают поразительны. Как что-то похожее получить в домашних условиях? Как вообще подойти к этой задаче и насколько она посильна?

## Иерархическое управление.

Для успешного управления существом, подобным живому потребуется одновременно решать огромное количество задач совершенно разной природы. Тут вам и системы контроля движения, обработка изображений, планирование, системы избегания опастностей. Размерность задачи велика и обозрить её целиком будет весьма непросто.

Однако мы знаем, что нужно делать. Декомпозиция задачи открывает путь к построению сложной системы из многих простых. Если каждый уровень обозрим, и предсказуем, то сложное становится возможным. Иерархическая система управления как слоёный пирог. Системы подчинены друг другу, каждая отвечает за свой узкий участок. 

В книге "Кибернетика или управление и связь в животном и машине" Винер пишет: "Чтобы взять карандаш, нужно на каждом шаге минимизировать степень того, в какой карандаш ещё не взят". Если я не могу взять карандаш сам, то для того, чтобы минимизировать степень его невзятости, я просто поручу это тому, кто на это способен. Бесконечное делегирование - это тот способ с помощью которого можно делать очень сложные вещи. Если я правильно сформулировал задачу своей подсистеме, то она, решая вопрос минимизации по сформулированной мной подзадаче, автоматически будет минимизировать степень того, в которой карандаш еще не взят, даже не подозревая об истинной цели всего мероприятия. 

В иерархической системе управления управление сводится к разбиению задачи на простые части. Для каждой возможной подзадачи есть специализированная подсистема, которая умеет эту подзадачу выполнять. Система высшего уровня не пытается контролировать движение каждого двигателя или мышцы. Вместо этого она формулирует для подчиненных структур ту ситуацию, которую ей желательно получить на том языке, который понятен этой подсистеме. Нижележащие системы получив это задание распаковывают его в более низкоуровневой трактовке и так до тех пор, пока желание съесть яблоко не превращается в потенциал действия на актуаторных нейронах.  

Пусть у нас есть некий механизм, который необходимо научить двигаться и решать задачи по взаимодействию с объектами. Мы не требуем пока, чтобы он проявлял чудеса интеллекта. Только простые двигательные задачи. Допустим, наш автоматон получил задание положить груз, лежащий в точке А в контейнер находящийся в точке Б. Как такую задачу можно решить в терминах иерархической системы?

Если проанализировать задачу, она состоит из нескольких явно выраженных подзадач. Во первых мы должны добраться до точки А, по пути не умерев. Найти груз. Взять груз, ничего не уронив и не умерев. Переместиться в точку Б, неся груз и по пути не умерев. Найти контейнер. Положить груз в контейнер, ничего на себя не опрокинув и не умерев. Каждая из отдельных задач раскладывается на несколько подзадач. Например, чтобы взять груз, нужно переместить манипулятор (ни с чем не столкнувшись), подвести манипулятор, не деформировав груз, и крепко захватить груз. 

Простые движения, вроде "сжать схват", или "разжать схват", или "переместить манипулятор" будут повторяться в разных двигательных подпрограммах. Из них строится задача более высокого уровня и так далее. Решить всю последовательность алгоритма одной функцией можно, но мы не сможем переиспользовать такое решение при изменении задачи. Принцип декомпозиция предлагает разбить эту функцию и переиспользовать результаты.

## Как это работает?

Введём некоторый стратегический контроллер. Перед ним поставлена задача перенести объект из точки А в точку Б. На каждом шаге алгоритма он должен оценить текущее состояние. 
Где находится груз? 
Может быть груз уже в точке Б? Окей. Задача выполнена. 
Груз у меня? Тогда я должен положить груз в контейнер в точке Б. 
Груз не у меня? Я должен взять груз. Где он? Может быть в точке А, или я его уронил. Не имеет значения, я должен взять груз.

Теперь я функция, которой велели взять груз. Я оцениваю состояние. 
Я далеко от груза? 
Да? Я попрошу контроллер позиционирования тела приблизить меня. 
Я достаточно близко? Я попрошу систему управления манипуляторами произвести захват объекта.

А вот я система управления позиционированием и мне велели двигаться к точке А. Я оцениваю своё состояние. 
Я могу продолжать движение? Как нет? Я лежу на полу? Думаю, мне стоит активировать программу востановления вертикального положения. 
Я могу продолжать движение? Да.
Я должен двигаться быстро? Если да, активирую контроллер бега и передаю ему направление. 
Если нет, передаю направление контроллеру шага. 
Впереди препятствие? Чуть-чуть скорректируем вектор направления, чтобы обойти препятствие стороной.

А вот я контроллер шага. Я смотрю своё состояние. 
Левая нога занесена, но довольно долго висит в воздухе, её стоит смещать вниз. 
Скорость смещения корпуса отличается от оптимальной. Перерасчитаем желаемое положение выходного сустава правой ноги. 
Левая нога может столкнуться с препятствием, сместим её чуть вправо. 
Есть потеря рановесия? Учтём это при постановке ноги.

А вот я контроллер отдельной конечности. У меня задача простая. Обеспечить требуемое относительное положение стопы и бедра. 
Я оцениваю состояние, смотрю текущие положения суставов и их скорости и расчитываю, как надо их поменять, чтобы получить требуемое, а команды эти отправляю контроллерам отдельных узлов.

И вот я система управления суставом. Всю свою сознательную жизнь я решал одну, строго одну и только одну задачу: Следил за тем, чтобы положение сустава не сбивалось относительно положения уставки. Что я делаю? Оцениваю состояние. Если положение не совпадает или скорость отлична от требуемой, я чуть-чуть поднапрягу мышцы. Я молодец!

Верите ли вы, что такая система может решить задачу?

В приведённом выше обзоре нехватает нескольких деталей. Во первых в ней неявно присутствует обработка сенсорной информации. Действительно, кто сказал, контроллеру шага, что нога находится в том состоянии, в котором она находится? Вы, кстати, обратили внимания, что в системе не задействовано никакой памяти? Есть два канала получения информации: восходящий и оценочный. Восходящий канал - это информация, которую предоставляет подсистема. Подсистема имеет некоторую оценку своего состояния и трактует его для вышестоящего уровня это локальная система. Канал оценки - это информация полученная из прочих источников, например в результате визуальной оценки состояния собственных конечностей. Оценочные каналы идут от внутренней модели, строящейся по результатом работы всех сенсоров системы. Это глобальная модель. Локальная модель работает быстро, но она ограничена своим уровнем понимания. Глобальная модель работает медленно, но даёт оценку на основе большего количества информации.

Системы управления можно дробить поразному. Низкие уровни достаточно хорошо оформлены и понятны, поскольку завязаны на аппаратную часть. С высшими сложнее. Иерархия может расти вверх достаточно долго. Пусть, например, задача по переносу груза - часть задачи по переносу содержимого всего склада. А что, если складов два. Это не то, что эффективно можно решить простым масштабированием.

## Пара слов про исток

Так или иначе, сверху всегда есть то, что принимает решение и вызывает нужную программу. Некий исток всего поведения. Контроллер стратегического планирования решает строго одну задачу. Максимизирует некоторый параметр, который может иметь, а может не иметь физического смысла. В нашем примере с карандашом смыслом всего было взятие карандаша, а оценка всего сущего выражалась в томительной мере неудовольствия тем простым фактом, что карандаш до сих пор не взят. Но, программа взятия карандаша может быть инициирована другой системой, что выражает лютое негодование тем фактом, что картина до сих пор не нарисована. Что за функция будет поставлена во главу угла - это вопрос применения системы. Потенциально система неограниченно растёт вверх, на каждом уровне решая всё более и более абстрактные задачи, но такое построение ограничено соображениями обозримости. Рано или поздно встаёт вопрос о некоем более разумном планировании, то есть о специальной системе, которая целенаправлено занимается планированием и генерацией цепочек подзадач. Эта система должна быть близка к истоку.

Исток поведения неизменен. Есть два способа заставить систему работать дольше одного цикла - первый связан с изменением среды. Если счастье робота определяется фактом наличия груза в контейнере, то до тех пор, пока груз на месте, робот не будет делать ничего. Но если груз выкинуть из контейнера, он пойдёт его возвращать. Другой способ в правильном формировании истока. Если функция хорошечности всё время падает, роботу придётся постоянно совершать действия по её повышению.

В книге "Автономный искусственный интеллект (Адаптивные и интеллектуальные системы)" за авторством профессора Жданова А.А., максимизируемый (минимизируемый) системой параметр называется оценкой хорошечности, а исток поведения хорошометром. Книга посвящена обучению и автономному поведению. Материал, изложенный в ней можно использовать, чтобы внести мотив обучения в автоматона. Хотя может показаться, что концепция обучаемых машин противна тем механистическим констрактам, о которых идёт речь в этой статье, принципы, на которых строятся эти системы отлично стыкуются. Можно даже сказать, что это таже самая система. Вопросы о том, как и когда использовать обучение, и когда этого делать не нужно, я постарался прояснить в прошлой своей статье. В ней показано, что кибернетическая система должна разворачивать функции обучения поверх некоторой наперёд заданной структуры, а структуру эту нужно разработать настолько тщательно, насколько это вообще возможно. Чем больше высокоуровневых функций будет у адаптивных механизмов к моменту начала обучения, тем проще ему будет учиться, и тем меньшая размерность будет у задачи обработки информации.

## Реиспользуемость и план работы.

Меня же, впрочем, сейчас интересует механистическая часть. Проектировать её следует с низких уровней, где связи жестко заданы. Стабильность контроллеров базовых перемещений и систем обработки информации открывают дорогу к экспериментам с управлением поведением. Как было показано выше, с целью эксперимента хорошометр может быть размещен в любой части цепи, начиная с самого нижнего уровня и вверх. Такая стратегия позволит двигаться последовательно. Если мы научимся двигать конечностями, то сможем научиться поддерживать позу и ходить. Научившись ходить, попробуем что-нибудь взять. Научившись брать попробуем что-либо куда-то перенести. Начиная от простых функций к сложным.

В следующий раз я расскажу, как могут быть устроены контроллеры суставов и конечностей. 
Будет много линейной алгебры и немного теории автоматическиго управления. На этом пока всё.
