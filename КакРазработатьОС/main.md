Операционная система - сложное архитектурное сооружение, в котором компоненты сильно завязаны друг на друга.

Когда человек ставит своей целью написать ОС, перед ним очень скоро возникает проблема интеграции компонент системы. Часто бывает, что компонент А не может быть написан, поскольку нет компонента Б, который сложно написать без компонента В, который практически невозможно написать в силу отсутствия компонента А. 

В силу такой сложной системы взаимозависимостей, объёмности, многогранности задачи, вместо инкрементальной разработки, которую хочет видеть конструктор, получается нелепая эволюционная разработка, требующая большого числа итераций и постоянных переписываний уже готовых кусков. После завершения такой разработки практически невозможно указать точку входа, то есть место, от которого эта разработка начиналась, и когда вы слышите вопрос новоинициированного писателя ОС, - "а с чего мне начать?", - вы не знаете, что ему ответить.

В этом цикле статей я бы хотел показать инкрементальную разработку операционной системы, которую можно использовать как отправную точку при эксперементах с самописными осями.

***

Рабочая среда.

*** 

Операционная система как библиотека.

По опыту работы с ОС мы знаем, что операционные системы развёртываются в автоматическом режиме, предоставляя пользователю виртуальное рабочее пространство терминала или же графической среды. В этой модели этап загрузки ОС регламентирован и неизменен. 

***

Немного об архитектуре ядра операционной системы и микроядре. 

Как мы все хорошо знаем, по способу взаимодействия компонент операционные системы бывают микроядерными и монолитными. Существуют также некоторые другие виды, такие как гибридные, объединяющие в себе свойства первых и вторых и разные модификации монолитных, призванных решить некоторые недостатки этого типа ОС.

По сути, выбирая между монолитом и микроядром, мы выбираем то, как будут взаимодействовать компоненты нашей системы: непосредственно, или же посредством специального механизма - шины сообщений. 

Преимущество шины сообщений в том, что компоненты системы развязываются на уровне модулей, а всё взаимодействие осуществляется в единой точке, что довольно сильно облегчает отладку. Кроме того механизм Send-Receive-Reply, типичный для микроядра естественным образом решает проблему ожидания потоков, которая требует отдельного решения в монолите. Однако шина сообщений очевидно медленнее прямого взаимодействия и требует некоторой дополнительной работы при написании интерфейсов компонент. Модель микроядра, кроме прочего имеет некоторый оверхед при организации ввода-вывода, драйверы устройств ввода-вывода, в этой модели являются процессами и имеют далеко не прозрачную реализацию.

Еще одно преимущество микроядра, мимо которого не следует проходить, показал QNX, в той связи, что несколько машин под управлением QNX могут организовывать взаимодействие на уровне процессов и shell инструкций благодаря поддержке ядром операционной системы передачи сообщений в локальной сети, как по шине сообщений. Это то, чего монолитное ядро не сможет пок не несомненно может помогать при отладке удалённого оборудования. Однако на практике тезис о распределённости QNX немного портит то обстоятельство, что проектирование интерфейсов поддерживающих распределённую работу требует обработки дополнительного набора ошибок, то есть такая работа в любом случае не бесшовна. 

Эпичная баталия сторонников монолита и микроядра выразилась в памятной беседе Эндрю Таненбаума и Линуса Торвальдса. Таненбаум, будучи учёным, архитектором и математиком отстаивал микроядро как формально верный способ построения операционной системы. Торвальдс же, будучи хакером, прогером и инженером, отстаивал монолит, поскольку не видел необходимости в дополнительном механизме.

Так как нет никаких сомнений в правоте Таненбаума, мы несомненно для нашей работы выберем сторону Торвальдса, и вот почему. Основное преимущество микроядра состоит в разделении модулей системы. Но этого же эффекта можно добиться и правильным проектированием монолитного ядра. Поэтому микроядро здесь является скорее теоретической моделью идеального ядра, которое может быть вполне воплощено на базе монолита, притом, что написать монолит проще.

Я далёк от мысли, что практический пример должен быть идеально выверен теоретически, а потому далёк от мысли, что микроядро - хороший пример для изучения.

***

Без MPU.
Платформы разработки Arduino Mega, stm32f4.

При разработки операционной системы нужно понимать, что пишем мы не что-нибудь, а виртуальную машину. Виртуальная машина сильно оторвана от железа. Ей должно быть совершенно всё равно, как и с каким железом работать. Однако, поскольку мы должны постоянно тестировать нашу абстракцию, необъодимо создать точку входа на тестовое железо, которая, очевидно не может не быть завязана на аппаратуру. Итак первое, что необходимо сделать - разработать драйверы взаимодействия с простейшими средствами ввода - вывода.

1. GPIO - драйвер.
2. UART - драйвер.
3. Комутатор прерываний.
4. Служба времени.
5. Служба таймеров.
6. Диспетчер задач, кооперативная многозадачность.
7. Ожидание.
8. Вытесняющая многозадачность.
9. Система ввода-вывода, uartring драйвер.
10. Системная консоль.
11. Файловая система, пространства имён.

К этому моменту у нас есть уже д