Операционная система - сложное архитектурное сооружение, в котором компоненты сильно завязаны друг на друга.

Когда человек ставит своей целью написать ОС, перед ним очень скоро возникает проблема интеграции компонент системы. Часто бывает, что компонент А не может быть написан, поскольку нет компонента Б, который сложно написать без компонента В, который практически невозможно написать в силу отсутствия компонента А. 

В силу такой сложной системы взаимозависимостей, объёмности, многогранности задачи, вместо инкрементальной разработки, которую хочется видеть конструктору, получается нелепая эволюционная разработка, требующая большого числа итераций и постоянных переписываний уже готовых кусков. После завершения такой разработки практически невозможно указать точку входа, то есть место, от которого эта разработка начиналась, и когда вы слышите вопрос новоинициированного писателя ОС, - "а с чего мне начать?", - вы не знаете, что ему ответить.

В этом цикле статей я бы хотел показать структуру операционной системы, которую можно использовать как отправную точку при эксперементах с самописными осями.

***

Без MPU.
Платформы разработки Arduino Mega, stm32f4.

При разработки операционной системы нужно понимать, что пишем мы не что-нибудь, а виртуальную машину. Виртуальная машина сильно оторвана от железа. Ей должно быть совершенно всё равно, как и с каким железом работать. Однако, поскольку мы должны постоянно тестировать нашу абстракцию, необъодимо создать точку входа на тестовое железо, которая, очевидно не может не быть завязана на аппаратуру. Итак первое, что необходимо сделать - разработать драйверы взаимодействия с простейшими средствами ввода - вывода.

1. GPIO - драйвер.
2. UART - драйвер.
3. Комутатор прерываний.
4. Служба времени.
5. Служба таймеров.
6. Диспетчер задач, кооперативная многозадачность.
7. Ожидание.
8. Вытесняющая многозадачность.
9. Система ввода-вывода, uartring драйвер.
10. Системная консоль.
11. Файловая система, пространства имён.

К этому моменту у нас есть уже д