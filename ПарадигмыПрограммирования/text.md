В начале было машинное слово и только дух носился над машиной. 

Во времена далёкие те, когда компьютеры были большие, программисты возвышены и сильны, а программы маленькие и прямые как стрела, не существовало ничего кроме кода и было это хорошо.  

По мере того, как программисты становились всё изощрённее, а программы множились и усложнялись, стало понятно, что переизбыток могущества приведёт молодой мир к трагедии. Творя по измышлению своему программы свои, программисты черпали силы в водах Хаоса первозданной вседозволенности, что против воли создателей, просверливался из каждого байта машинной инструкции. 

И увидели программисты, что могущественны они слишком и от того сложно им код свой писать и масштабировать. И поняли они, что нужны им правила, чтобы удерживать могущество своё в рамках заданных. И создали они парадигмы. 

И первой парадигмой стало программирование процедурное.

Понятие процедуры родилось из повсеместной необходимости делать над данными раз за разом одни и теже действия. Чтобы не прописывать такие действия стопятьсот раз, логично выделить небольшой кусок кода который будет хорошо выполнять эту небольшую процедуру и при необходимости к нему обращаться. И взглянули программисты на процедуры и поняли они, что это хорошо. И пользоваться ими стали.

Повсеместное распространение процедур привело к тому, что программы довольно сильно унифицировались. Вместо раздольного хаоса первородного и всемогущества над регистрами, программисты умерили возможности свои и в код свой привнесли определённый стиль подпрограмм и аргументов. С одной стороны, хотя программисты всё еще были могущественны и сильны и могли вытворять с процессором всё, что производитель разрешил, они решили что преимущества процедурного стиля, который принёс возможность не повторять однажды написанное, ограничивать область необходимого одномоментного интеллектуального охвата малым пространством обособленной ответственности и кристально чисто вылизывать код не весь и разом, но позадачно подкупили их и отказались они от силы своей. И эра процедурная настала. 

Тем временем в мир приходили новые программисты и не так возвышены и сильны были они исложно им было в словах машинных разбираться и сообща создали себе они инструменты для того, чтобы немощь свою побороть и появились так сначала Assembler, а позже позже Fortran и Algol. Немодно стало кодом машинным повелевать и над процессором напрямую властвовать. Пусть компилятор трудится, говорили программисты и еще толику могущества своего поутратили и хаос поослабили. Заодно и процедурную парадигму окончательно в ранг закона возвели.

Но не унимались программисты и интерактивности возжелали и repl технологию изобрели, чтобы делишки свои не отходя от кассы выдумывать и в жизнь претворять и прототипы первых интерпретаторов появились во время то, чтобы кодом программ машинных управлять. И вскоре из repl-а вышли скрипты и стал мир разделён между программами машинными и скриптами интерпретируемыми и было в то время счастье, ибо не как сейчас было тогда и всегда ясно было, где программа, а где скрипт. 

Долгим был мир в ту эпоху, но не стоял прогресс на месте. Захотели программисты не только код писать, но и читать его переодически, дабы поддерживать его и масштабировать. И поняли они, что сложно им, ибо даже верховенство процедурного бога недостаточно было, дабы порядок в коде навести. И вознёс тогда Дейкстра глас свой и впоследствии теоремой теоремы Бёма — Якопини вооружившись, надругался он над оператором goto, утвердив, что слово это порочно и слов while, for и if достаточно быть должно. И сказав так, изгнал goto лешив программистское сообщество еще одного могущественного артефакта, утвердив структурную парадигму на века вечные. Не сдался, впрочем goto и даже сейчас нет нет да и проскакивает он в коде иного ностальгирующего по былому могуществу программиста. Стыдливо оглядывается программист, не видит ли кто, метку создаёт, goto пишет и процедуру goto использующую в дальний файл прячет... От греха.

