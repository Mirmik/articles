Привет друг. Удачно ты заглянул на огонёк, ибо сегодня тебе сказку скажу о том, как программисты обменяли могущество великое на удобство. О том, как последовательный отказ от тех или иных инструментов приводил к качественному изменению обеспечения програмного. О том, как ограничение на инструментарий придаёт изделию кодерскому свойства новые. И наконец о том, что же такое парадигма программирования, ибо вопрос великий сей умы волнует и понятия единого средь кодеров нет и согласия. А коли не волнует тебя проблема эта, дальше листай и вид сделай, что не слышал о сказке моей. Зайдёшь же коли на огонёк, так знай, что словца красивого ради не всегда сказитель хронологию блёл и на совести его перегибы все и недомолвки.

***

В начале было слово машинное и только дух носился над вычислителем. 

Во времена далёкие те, компьютеры были велики размерами своими, программисты возвышены и сильны, а программы их - маленькие и прямые как стрела. Не существовало ничего кроме самого кода и было это хорошо.  

По мере того, как программисты становились всё изощрённее, а программы множились и усложнялись, стало понятно, что могущественны программисты слишком, и что переизбыток могущества не к эпохи изобилия и процветания ведёт, но к раздору и трагедии. Творя по измышлению своему программы свои, программисты черпали силы в водах Хаоса первозданной вседозволенности, что против воли создателей, просверливался из каждого байта машинной инструкции и кто во что горазд творил и небыло видения общего и понимания. 

Увидели программисты, что могущественны они слишком и от того сложно им код свой писать и масштабировать. И поняли они, что нужны им правила, чтобы удерживать могущество своё в рамках заданных и результаты предсказуемые получать, а не выхремунду какую. Собрались они и тогда создали парадигмы, дабы силу свою запечатать на веки вечные. 

И первым кольцом магическим стало программирование процедурное, ибо повсеместной была необходимость делать над данными раз за разом одни и теже действия. Чтобы не прописывать действия такие раз сто и пятьсот, логично было выделить кусок небольшой кода, который бы выполнял очерченную работу и делал бы это хорошо. И к нему обращаться регулярно регулярно решили программисты, аки волхву и мудрецу великому. Создали программисты процедуры, взглянули на них и поняли, что это хорошо. И пользоваться ими с тех пор стали.

Повсеместное распространение процедур и функций привело к тому, что программы довольно сильно унифицировались. Вместо раздольного хаоса первородного и всемогущества над регистрами, программисты умерили возможности свои и в код свой привнесли стиль подпрограмм и аргументов. С одной стороны, хотя кодеры всё еще были могущественны и сильны и могли вытворять с процессором всё, что производитель разрешил, они решили что преимущества процедурного стиля, который принёс возможность не повторять однажды написанное, и ограничивать область необходимого одномоментного интеллектуального охвата, кристально чисто вылизывать код не весь и разом, но позадачно, подкупили их и отказались они от части силы своей, ибо больше не писали они иначе, нежели как парадигма им велеть стала. И эра процедурная настала. 

Тем временем в мир приходили новые программисты и не так возвышены были и сильны они как предшественники, и сложно им было в словах машинных разбираться. И тогда сообща создали себе они инструменты для того, чтобы немощь свою побороть и появились так сначала Assembler, а позже позже Fortran и Algol. Немодно стало кодом машинным повелевать и над процессором напрямую властвовать. Пусть компилятор трудится, говорили программисты и еще толику могущества своего поутратили и хаос поослабили. Заодно и процедурную парадигму окончательно в ранг закона возвели.

Но не унимались программисты и интерактивности возжелали и repl технологию изобрели, чтобы делишки свои не отходя от кассы выдумывать и в жизнь претворять, и прототипы первых интерпретаторов появились во время то. И вскоре из repl-а вышли скрипты и стал мир разделён между программами машинными и скриптами интерпретируемыми и было в то время счастье, ибо всегда ясно было, где программа, а где скрипт, а не как сейчас, когда интерпретируемое компилируют, а компилируемое интерпретируют. Еще дальше программисты от железа стали и уж не знали они уже как АЛУ работает, ибо ОС появились и необязательно матчасть знать стало, о чем впрочем никто не горевал, покуда махали все, улыбались и радовались.

Долгим был мир в ту эпоху, но не стоял прогресс на месте. Захотели программисты не только код писать, но и читать его переодически, дабы поддерживать его и масштабировать. И поняли они, что сложно им, ибо даже верховенство процедурного бога недостаточно было, дабы порядок в коде навести. И пришёл тогда техношаман один, которого Дейкстра звали, и Вирт ему помогал. Вознёс Дейкстра глас свой и впоследствии теоремой Бёма - Якопини вооружившись, надругался он над оператором goto, утвердив, что колдовство оператора сего порочно и слов while, for и if достаточно быть должно для хакера любого. И сказав так, изгнал goto лишив сообщество еще одного могущественного артефакта, утвердив структурную парадигму на века вечные. Опечалился goto, но не сдался произволу героическому, и даже сейчас нет нет да и проскакивает он в коде иного ностальгирующего по былому величию кодера. Стыдливо оглядывается он, не видит ли кто, метку создаёт, goto пишет и процедуру свою в дальний файл прячет, дабы не видел никто, и слёзы тогда на глаза статического анализатора иного наворачиваются, ибо не умеют статические анализаторы работать, когда парадигма не соблюдается.

Красивым стал код, табуляцией и скобочками размеченный, циклами и блоками обрамлённый и благодарны кодеры техношаману были и теореме его и командное взаимодействие между программистами, хакерами, и кодерами налаживаться начало, ибо возможно стало не только код писать, но и читать его и даже понимать переодически.

Во время то программисты тему искуственного интеллекта полюбили и думали думу, как мозг машинный создать, чтобы гомункулуса породить, чтоб чёрную работу делать его заставить. И создали они тогда Prolog, экспертные системы и теорию автоматического доказательства, да и под шумок парадигму еще одну изобрели и логической её назвали. Мало кто понял, что за парадигма это такая и в чем соль её и суть, но для порядку в книжечку внесли и номер присвоили. Да и забыли про неё, потому что не тянула она на парадигму, ибо узка была слишком и самобытна. 

А тем временем, благодаря структурной парадигме стали команды кодеров продукты создавать и код свой множить и кодом своим делится и поняли они, что опять предел возник перед ними, ибо разваливался под собственной тяжестью код программ их, размеров определённых достигнув. Но были инженеры, глазами вооружённые и увидели они проблему эту задолго до того как в полный рост она стала, и созданы руками их были тогда Simula и Smalltalk, и Алан Кей речь свою произнёс. Но умна слишком речь его была и смутила она программистов, детей их и детей детей их, и увы, детей детей детей их и много еще поколений смутит и смущать будет, ибо вместо луны над водой смотрели кодеры на палец, а вместо декомпозиции и иерархии видели инкапсуляцию, полиморфизм, наследование, да описание объектов реального мира, а абстракцией во время просмотра закусывали, что конечно никакого отношения к истинной сути ООП не имело, но только внешнюю форму немного затрагивало. Опечалился тогда Алан Кей и сказал, что C++ - это не true ООП и вообще всё тлён, что не свято, но поздно было уже, ибо гвалт поднялся такой, что ни в сказке сказать ни пером описать. 

Однако, нет нет, но стронулось дело и не мытьём так катанием научились кодеры объектному мышлению, данные с кодом увязывали, из объектов объекты складывали и тем самым код декомпозировали и иерархически выстраивали. И интерфейсами пользоваться научились, и окончательно хорошо стало, ибо программы теперь не только на процедуры разбиты были, но и на обособленные кусочки данных и методы их, что связность программ понизило, а простоту чтения кода повысило. А что до обмена сообщениями, о котором Алан Кей говорил, позабыли о нем, ибо решили, что негоже кодерам праведным письма писать, когда напрямую в гости ходить можно, лишь бы только интерфейс соблюдался. И на тему туже спустя время долгое эпичный срач был между святым воителем Торвальдсом и мудрецом почитаемым Таненбаумом, но другая история эта, казалось бы не о том она вообще и к чему тут упомянута непонятно, да и дело ли нам кодерам простым в дела святых воителей и мудрецов почитаемых лезть.

С тех пор и поныне настала эпоха парадигмы объектной, и немыслимо программирование уже без объектов этих, но и тут недовольные оказались и говорили они слова верные, что ООП софт замедляет и избыточность его повышает и качество программ падает, ибо жёстки слижком интерфейсы и действий лишних много делать приходится, но не слушали их программисты остальные и иерархии объектов в продакшн выкатывали и Java создали и DotNet. А под шумок всё памятью и быстродействием закидали, дабы быстродействие повысить и окончательно недовольным глотки заткнуть. Немодно стало бесклассовый код писать, хотя нет классов никаких в словах машинных и не было никогда, а потому всё дальше отдалялись кодеры от изначальной природы своей и не могли больше процессором на мощность полную повелевать и машиной фон Неймана от сердца к генератору тактового импульса править.

Тем временем, мужи учёные всё не унимались и споры свои вели о том, как код писать правильно, чтобы ошибок недопускать, чтоб выполнялся предсказуемо и творцов не удивлял поведением своим и норовом. И решили они, что чистота и иммутабельность есть благо, а глобальные переменные и сайдэффекты есть зло. И хорошо было это, но сказали они также, что вывод информации на экран должен оформляться как возврат из функции модифицированного объекта вселенной, что всё есть монада, что теория категорий над типами повелевает, а также, что reduce, map, select и прочие слова страшные. А под конец еще Haskell изобрели, чтобы окончательно всех запустать. Почесали затылки программисты, не поняли, что функциональное программирование это про объекты, только иммутабельные и без глобальщины, а решили, что сложно это и непонятно, а кто разобрался с ФП, тот монада какая-то заумная. Однако, концепция чистых функций неплохо зашла и научились прогеры тогда юниттесты писать, а в последствии continuos integration изобрели зачем-то. 

Заметить стоит, что хотя умы ученые код математический завсегда писали, но к типам базовым термин иммутабельности неприменим особо, а потому функциональная парадигма никак не раньше объектной возникла, ибо про объекты она, а не про математику, ктоб там что не думал и не утверждал, и если программист объектно не пишет, то функционально он точно писать не сможет. Но если пишет он функционально, то отказывается от изменения состояния объектов своих, зато строгую логическую цепочку вывода получает, а заодно возможность кеширования и мемоизации. А всё что про монады и композиции функций, так это метод, а не результат. Палец то, а не луна. Так вновь от части силы своей отказываясь, новые свойства коду своему кодеры придавать научились и ограничиваясь в одном в другом сильнее становились, а хорошо это или плохо, не мне судить.

Покуда скрипты и интерпретаторы развивались, нашлись кодеры немытые, которые решили, что не хотят они процессору объяснять, как дом строить, но хотят просто сказать, каким быть тот должен и как выглядеть снаружи и интерьеру какому быть изнутри желательно. И создали они языки разметки, и xaml, и yaml, и css и много других интересных штук, и заодно web по ходу дела породили и на том декларативное программирование постулировали. А для тех неучей, что нехотел желания свои мимолётные описывать, но как раньше хотели кирпичи складывать, презрительно всё недекларативное императивным обозвали и тем самым дихотомию императивной и декларативной парадигм породили. Посмотрели на это кодеры мытые да чистые, плечами пожали и сказали "Ну, оке... Вроде тоже хорошо".

И вот мир стал таким, каким мы его знаем у выдохнуть бы нам бы надо бы, но еще одна важная парадигма прошла мимо нас незамеченной. Ряд задач связанных с обработкой данных, приходящих потоком или в непредсказуемые моменты времени не позволяли хакерам до кодерам писать код императивненько, ибо нельзя императивно обработать то, что непонятно когда и в каком количестве в систему попадает и создали тогда кодеры да хакеры виджеты для гуи, сервисы для вэба и конвееры для обработки данных и увязали react, qt, да simulink с labview в event-driven или реактивную парадигму, как нравится кому, ибо вывернуть код пришлось им и на колбеках да конвеерах строить его. На этапе инициализации структуры выстраивали они единожды и после только данные гнали через неё и считали они, что хорошо это и воистину было так, ибо как по другому делать никто не знал никогда и впредь не знает.

Много других парадигм изобрели кодеры, и книжки умные писали и конференции проводили. Тут вам и аспектно-ориентированное, и компонентно-ориентированнное, и реактивно-функциональное, и прототипное, которое тоже ООП, но подругому. В общем чего тут только нету, однако всегда и везде суть парадигмы в том состоит, чтобы так ограничить могущество своё и инструменты используемые, чтобы результат работы твоей, о Кодер, силу имел привнесённую, потому что свойства кода твоего зависят от того, что ты используешь и в этом суть парадигм.