Привет друг. Удачно ты заглянул на огонёк, ибо сегодня тебе сказку скажу о том, как программисты обменяли могущество на удобство, о том, как последовательный отказ от тех или иных инструментов приводил к качественному изменению обеспечения програмного, о том, как ограничение на инструментарий придаёт изделию новые свойства и наконец о том, что же такое парадигма программирования. А коли не волнует тебя вопрос сей, дальше листай и вид сделай, что не слышал о сказке этой. А коли зайдёшь ты на огонёк мой, то знай, что словца красивого ради не всегда автор хронологию блёл и на совести его перегибы все и недомолвки.

***

В начале было слово машинное и только дух носился над вычислителем. 

Во времена далёкие те, компьютеры были большие, программисты возвышены и сильны, а программы маленькие и прямые как стрела. Не существовало ничего кроме самого кода и было это хорошо.  

По мере того, как программисты становились всё изощрённее, а программы множились и усложнялись, стало понятно, что могущественны программисты слишком, и что переизбыток могущества ведёт мир к трагедии. Творя по измышлению своему программы свои, программисты черпали силы в водах Хаоса первозданной вседозволенности, что против воли создателей, просверливался из каждого байта машинной инструкции. 

И увидели программисты, что могущественны они слишком и от того сложно им код свой писать и масштабировать. И поняли они, что нужны им правила, чтобы удерживать могущество своё в рамках заданных и результаты предсказуемые получать, а не выхремунду какую. И создали они тогда парадигмы, чтобы силу свою запечатать. 

Первой парадигмой стало программирование процедурное, ибо повсеместной была необходимость делать над данными раз за разом одни и теже действия. Чтобы не прописывать действия такие раз сто и пятьсот, логично было выделить кусок небольшой кода, который бы выполнял небольшую работу эту и делал бы это хорошо. И к нему обращаться регулярно. И создали программисты процедуры, взглянули на них и поняли, что это хорошо. И пользоваться ими стали.

Повсеместное распространение процедур привело к тому, что программы довольно сильно унифицировались. Вместо раздольного хаоса первородного и всемогущества над регистрами, программисты умерили возможности свои и в код свой привнесли стиль подпрограмм и их аргументов. С одной стороны, хотя программисты всё еще были могущественны и сильны и могли вытворять с процессором всё, что производитель разрешил, они решили что преимущества процедурного стиля, который принёс возможность не повторять однажды написанное, ограничивать область необходимого одномоментного интеллектуального охвата малым пространством обособленной ответственности, кристально чисто вылизывать код не весь и разом, но позадачно, подкупили их и отказались они от части силы своей и всё процедурами и функциями оформлять стали. И эра процедурная настала. 

Тем временем в мир приходили новые программисты и не так возвышены были и сильны они, и сложно им было в словах машинных разбираться. И тогда сообща создали себе они инструменты для того, чтобы немощь свою побороть и появились так сначала Assembler, а позже позже Fortran и Algol. Немодно стало кодом машинным повелевать и над процессором напрямую властвовать. Пусть компилятор трудится, говорили программисты и еще толику могущества своего поутратили и хаос поослабили. Заодно и процедурную парадигму окончательно в ранг закона возвели.

Но не унимались программисты и интерактивности возжелали и repl технологию изобрели, чтобы делишки свои не отходя от кассы выдумывать и в жизнь претворять, и прототипы первых интерпретаторов появились во время то, чтобы кодом программ машинных компиляторами накомпиленных повелевать. И вскоре из repl-а вышли скрипты и стал мир разделён между программами машинными и скриптами интерпретируемыми и было в то время счастье, ибо не как сейчас было тогда и всегда ясно было, где программа, а где скрипт. Еще дальше программисты от железа стали и уж не знали они уже как АЛУ работает, ибо ОС появились и необязательно матчасть знать стало, о чем впрочем никто не горевал, покуда махали все и улыбались.

Долгим был мир в ту эпоху, но не стоял прогресс на месте. Захотели программисты не только код писать, но и читать его переодически, дабы поддерживать его и масштабировать. И поняли они, что сложно им, ибо даже верховенство процедурного бога недостаточно было, дабы порядок в коде навести. И пришёл тогда техношаман один, которого Дейкстра звали, и Вирт ему помогал. Вознёс Дейкстра глас свой и впоследствии теоремой Бёма — Якопини вооружившись, надругался он над оператором goto, утвердив, что колдовство оператора сего порочно и слов while, for и if достаточно быть должно для хакера любого. И сказав так, изгнал goto лишив сообщество еще одного могущественного артефакта, утвердив структурную парадигму на века вечные. Опечалился goto, но не сдался произволу героическому, и даже сейчас нет нет да и проскакивает он в коде иного ностальгирующего по былому величию кодера. Стыдливо оглядывается он, не видит ли кто, метку создаёт, goto пишет и процедуру свою в дальний файл прячет... Дабы не видел никто.

Красивым стал код, табуляцией и скобочками размеченный, циклами и блоками обрамлённый и благодарны кодеры техношаману были и теореме его и индустрия командное взаимодействие мехду программистами, хакерами и кодерами налаживать начала, ибо возможно стало не только код писать, но и читать его и даже понимать переодически.

Во время то программисты тему искуственного интеллекта полюбили и думали думу, как мозг машинный создать, чтобы гомункулуса породить, чтоб чёрную работу делать его заставить. И создали они тогда Prolog, экспертные системы и теорию автоматического доказательства, да и под шумок парадигму еще одну изобрели и логической её назвали. Мало кто понял, что за парадигма это такая и в чем соль её и суть, но для порядку в книжечку внесли и номер присвоили. Да и забыли про неё, потому что не тянула она на парадигму, ибо узка была слишком и самобытна. 

А тем временем, благодаря структурной парадигме стали команды кодеров продукты создавать и код свой множить и кодом своим делится и поняли они, что опять предел возник перед ними, ибо разваливался под собственной тяжестью код программ их, размеров определённых достигнув. Но были инженеры, глазами вооружённые и увидели они проблему эту задолго до того как в полный рост она стала, и созданы руками их были тогда Simula и Smalltalk, и Алан Кей речь свою произнёс. Но умна слишком речь его была и смутила она программистов, детей их и детей детей их, и увы, детей детей детей их тоже смутит и много еще поколений смущать будет, ибо вместо луны над водой смотрели они на палец, а вместо декомпозиции и иерархии на инкапсуляцию, полиморфизм, наследование, да описание объектов реального мира, а абстракцией во время просмотра закусывали, что конечно никакого отношения к истинной сути ООП не имело, но только внешнюю форму немного затрагивало. Опечалился тогда Алан Кей и сказал, что C++ - это true ООП и вообще всё тлён, что не свято, но поздно было уже. 

Однако, нет нет, но стронулось дело и не мытьём так катанием научились кодеры объектному мышлению, данные с кодом увязывали, из объектов объекты складывали и тем самым код декомпозировали и иерархически выстраивали. И интерфейсами пользоваться научились, и окончательно хорошо стало, ибо программы теперь не только на процедуры разбиты были, но и на обособленные кусочки данных и методы их, что связность программ понизило, а простоту чтения кода повысило, ибо хорошо данные с методами своими теперь увязаны были. А что до обмена сообщениями, о котором Алан Кей говорил, позабыли о нем, ибо решили, что негоже кодерам праведным письма писать, когда напрямую в гости ходить можно, лишь бы только интерфейс соблюдался. И на тему туже спустя время эпичный срач между святым воителем Торвальдсом был и мудрецом почитаемым Таненбаумом, но другая история эта, казалось бы не о том она вообще и к чему тут упомянута непонятно, да и дело ли нам кодерам простым в дела святых воителей и мудрецов почитаемых лезть.

С тех пор и поныне настала эпоха парадигмы объектной, немыслимо программирование уже без объектов, но и тут недовольные оказались и говорили они слова верные, что ООП софт замедляет и избыточность его повышает и качествор программ падает, ибо жёстки слижком интерфейсы и действий лишних много делать приходится, но не слушали их программисты и иерархии объектов в продакшн выкатывали и Java создали и DotNet. А под шумок всё памятью и быстродействием закидали, дабы быстродействие повысить и окончательно недовольным глотки заткнуть. Немодно стало бесклассовый код писать, хотя нет классов никаких в словах машинных и не было никогда, а потому всё дальше отдалялись кодеры от изначальной природы своей.

Тем временем, мужи учёные всё не унимались и споры свои вели о том, как код писать правильно, чтобы ошибок недопускать .